// Mock external dependencies
jest.mock('../lib/config');
jest.mock('../lib/logger');
jest.mock('../lib/project');
jest.mock('fs-extra');

// Mock process.exit to prevent test termination
const originalExit = process.exit;
beforeAll(() => {
  process.exit = jest.fn();
});
afterAll(() => {
  process.exit = originalExit;
});

// Import the modules we want to test
const config = require('../lib/config');
const projectDetector = require('../lib/project');
const fs = require('fs-extra');

describe('Requirements Agent', () => {
  let mockAgent;

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();

    // Setup default mock implementations
    config.load.mockResolvedValue({
      paths: {
        specifications: '/mock/project/docs/specifications'
      }
    });

    projectDetector.isCodeMaestroProject.mockResolvedValue(true);
    projectDetector.getProjectStatus.mockResolvedValue({
      phase: 1,
      task: 'Analyze project requirements and create specification document',
      role: 'Product Manager'
    });

    fs.ensureDir.mockResolvedValue();
    fs.writeFile.mockResolvedValue();
    fs.readdir.mockResolvedValue([]);
  });

  describe('RequirementsAgent class', () => {
    beforeEach(async () => {
      const { RequirementsAgent } = require('../commands/requirements');
      mockAgent = new RequirementsAgent();
      await mockAgent.initialize();
    });

    test('should initialize with correct paths', () => {
      expect(mockAgent.specsDir).toBe('/mock/project/docs/specifications');
    });

    test('should validate phase correctly', async () => {
      const result = await mockAgent.validatePhase();
      expect(result).toBe(true);
    });

    test('should reject invalid phase', async () => {
      projectDetector.getProjectStatus.mockResolvedValue({
        phase: 2,
        task: 'Design system architecture',
        role: 'Software Architect'
      });

      const result = await mockAgent.validatePhase();
      expect(result).toBe(false);
    });

    test('should create specification template', async () => {
      const template = await mockAgent.createSpecificationTemplate();

      expect(template).toContain('# Product Specification');
      expect(template).toContain('## Executive Summary');
      expect(template).toContain('Functional Requirements');
      expect(template).toContain('Non-Functional Requirements');
      expect(template).toContain('*Generated by CodeMaestro Requirements Agent*');
    });

    test('should create competitive analysis template', async () => {
      const template = await mockAgent.createCompetitiveAnalysisTemplate();

      expect(template).toContain('# Competitive Analysis');
      expect(template).toContain('## Executive Summary');
      expect(template).toContain('Direct Competitors');
      expect(template).toContain('SWOT Analysis');
      expect(template).toContain('*Generated by CodeMaestro Requirements Agent*');
    });

    test('should generate user stories', async () => {
      const features = [
        {
          name: 'User Authentication',
          description: 'allow users to log in securely',
          benefit: 'users can access their accounts',
          userType: 'end user'
        }
      ];

      const stories = await mockAgent.generateUserStories('Test Product', features);

      expect(stories).toHaveLength(1);
      expect(stories[0].epic).toContain('Feature 1: User Authentication');
      expect(stories[0].story).toContain('As a end user');
      expect(stories[0].acceptanceCriteria).toBeDefined();
    });

    test('should create user story template', async () => {
      const template = await mockAgent.createUserStoryTemplate();

      expect(template).toContain('# User Stories');
      expect(template).toContain('## Overview');
      expect(template).toContain('**As a** [type of user]');
      expect(template).toContain('*Generated by CodeMaestro Requirements Agent*');
    });

    test('should save documents correctly', async () => {
      const filePath = await mockAgent.saveDocument('test.md', 'test content');

      expect(filePath).toBe('/mock/project/docs/specifications/test.md');
      expect(fs.writeFile).toHaveBeenCalledWith(
        '/mock/project/docs/specifications/test.md',
        'test content'
      );
    });

    test('should list existing documents', async () => {
      fs.readdir.mockResolvedValue(['spec.md', 'analysis.md', 'not-md.txt']);

      const documents = await mockAgent.listExistingDocuments();

      expect(documents).toEqual(['spec.md', 'analysis.md']);
    });
  });

  describe('requirementsCommand execution', () => {
    let consoleSpy;

    beforeEach(() => {
      consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    });

    afterEach(() => {
      consoleSpy.mockRestore();
    });

    test('should show guide by default', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      await requirementsCommand('guide', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ“‹ Phase 1 Requirements Guide')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Phase 1 Objective:')
      );
    });

    test('should create specification template', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      // Mock process.exit to avoid actual exit
      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {});

      await requirementsCommand('spec', { template: true });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ“‹ Product Specification Creation')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('âœ… Specification template created')
      );
      expect(fs.writeFile).toHaveBeenCalled();

      mockExit.mockRestore();
    });

    test('should create competitive analysis template', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      await requirementsCommand('competitive', { template: true });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ† Competitive Analysis')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('âœ… Competitive analysis template created')
      );
    });

    test('should create user stories template', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      await requirementsCommand('stories', { template: true });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ“– User Stories Generation')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('âœ… User stories template created')
      );
    });

    test('should list documents', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      fs.readdir.mockResolvedValue(['spec.md', 'analysis.md']);

      await requirementsCommand('list', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ“ Existing Requirements Documents')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Found 2 document(s)')
      );
    });

    test('should show empty list when no documents exist', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      fs.readdir.mockResolvedValue([]);

      await requirementsCommand('list', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('No requirements documents found')
      );
    });

    test('should handle invalid phase', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      projectDetector.getProjectStatus.mockResolvedValue({
        phase: 2,
        task: 'Design system architecture',
        role: 'Software Architect'
      });

      await requirementsCommand('spec', { template: true });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Requirements Agent is designed for Phase 1')
      );
      expect(fs.writeFile).not.toHaveBeenCalled();
    });

    test('should generate user stories from features', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      const featuresJson = '[{"name": "Login", "description": "allow login", "benefit": "secure access"}]';

      await requirementsCommand('stories', {
        generate: true,
        features: featuresJson
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('âœ… User stories generated from features')
      );
      expect(fs.writeFile).toHaveBeenCalled();
    });

    test('should handle invalid features JSON', async () => {
      const { requirementsCommand } = require('../commands/requirements');

      await requirementsCommand('stories', {
        generate: true,
        features: 'invalid json'
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('âŒ Failed to parse features JSON')
      );
    });
  });

  describe('Template content validation', () => {
    test('specification template should have all required sections', async () => {
      const { RequirementsAgent } = require('../commands/requirements');
      const agent = new RequirementsAgent();
      await agent.initialize();

      const template = await agent.createSpecificationTemplate();

      expect(template).toContain('## Executive Summary');
      expect(template).toContain('### Functional Requirements');
      expect(template).toContain('### Non-Functional Requirements');
      expect(template).toContain('## Constraints');
      expect(template).toContain('## Assumptions');
      expect(template).toContain('## Stakeholder Analysis');
      expect(template).toContain('## Success Metrics');
    });

    test('competitive analysis template should have complete structure', async () => {
      const { RequirementsAgent } = require('../commands/requirements');
      const agent = new RequirementsAgent();
      await agent.initialize();

      const template = await agent.createCompetitiveAnalysisTemplate();

      expect(template).toContain('## Market Overview');
      expect(template).toContain('## Direct Competitors');
      expect(template).toContain('#### SWOT Analysis');
      expect(template).toContain('## Competitive Advantages');
      expect(template).toContain('## Recommendations');
    });

    test('user stories template should have proper format', async () => {
      const { RequirementsAgent } = require('../commands/requirements');
      const agent = new RequirementsAgent();
      await agent.initialize();

      const template = await agent.createUserStoryTemplate();

      expect(template).toContain('### Story Format');
      expect(template).toContain('**As a** [type of user]');
      expect(template).toContain('**I want** [some goal]');
      expect(template).toContain('**So that** [some reason]');
      expect(template).toContain('### Definition of Ready');
      expect(template).toContain('### Definition of Done');
    });
  });
});