# Code Generation from Acceptance Criteria (Improvement #12)

**Version:** 1.0
**Date:** 2026-01-13
**Status:** âœ… Documented (Integration Pending)
**Risk:** âœ… ZERO - Generates stubs only, developers implement
**Effort:** 8-10 hours

---

## Overview

Code Generation from Acceptance Criteria (AC) automatically generates test stubs from Given/When/Then/And format ACs. This accelerates test implementation and ensures 100% AC coverage.

**Key Principle:** Generate test structure and skeleton. Developers implement test logic.

---

## Problem Statement

**Current State:**
- Developers manually write tests from acceptance criteria
- AC structure (Given/When/Then) not reflected in test code
- Easy to miss AC coverage
- Repetitive test boilerplate

**User Pain Points:**
1. Translating AC to test code is manual and time-consuming
2. Forgetting to test all "And" clauses
3. Inconsistent test structure across team
4. No automatic AC-to-test traceability

---

## Solution: Automated Test Stub Generation

### Input: Acceptance Criteria

From locked specification:

```markdown
## AC-1.2: User login with valid credentials

**Priority:** High
**Linked Req:** FR-001 (User Authentication)
**Verification:** Automated Test

**Scenario:**
Given: User has valid username and password
When: User submits login form
Then: User is redirected to dashboard
And: Session cookie is set with 24h expiry
And: Last login timestamp is updated
```

### Output: Test Stub

```typescript
// Generated: tests/auth/login.test.ts
// AC-1.2: User login with valid credentials
// Generated by CodeMaestro v1.0.0 on 2026-01-13
//
// âš ï¸ IMPLEMENTATION REQUIRED
// This is a test stub. Implement the test logic in the TODO sections.

import { describe, it, expect } from '@jest/globals';
import { request } from 'supertest';
import { app } from '../../src/app';

describe('AC-1.2: User login with valid credentials', () => {
  // TODO: Setup - Create test fixtures
  beforeEach(() => {
    // TODO: Initialize test database
    // TODO: Create test user with valid credentials
  });

  // TODO: Teardown - Clean up test data
  afterEach(() => {
    // TODO: Clear test database
    // TODO: Reset authentication state
  });

  it('redirects to dashboard on valid login', async () => {
    // Given: User has valid username and password
    const user = {
      username: 'test_user',
      password: 'valid_password123'
      // TODO: Use actual test fixtures
    };

    // When: User submits login form
    const response = await request(app)
      .post('/api/login')
      .send(user);
      // TODO: Add headers if needed

    // Then: User is redirected to dashboard
    expect(response.status).toBe(302);
    expect(response.headers.location).toBe('/dashboard');
    // TODO: Verify redirect is correct

    // And: Session cookie is set with 24h expiry
    expect(response.headers['set-cookie']).toBeDefined();
    const cookie = response.headers['set-cookie'][0];
    // TODO: Verify cookie expiry is 24h
    // TODO: Verify cookie is httpOnly and secure

    // And: Last login timestamp is updated
    // TODO: Query database to verify last_login updated
    // TODO: Assert timestamp is recent (within last minute)
  });

  // TODO: Add negative test cases
  // - Invalid password
  // - Invalid username
  // - Missing credentials
  // - Account locked
  // - Session already exists
});
```

---

## Command: `/generate test [AC-ID]`

### Syntax

```bash
/generate test AC-1.2
/generate test AC-1.2 --language=typescript
/generate test AC-1.2 --framework=jest
/generate test AC-1.2 --output=tests/auth/login.test.ts
```

### Options

| Option | Description | Default |
|--------|-------------|---------|
| `--language` | Target language (typescript, javascript, python, java, go, rust) | Detect from project |
| `--framework` | Test framework (jest, vitest, pytest, junit, testify, cargo-test) | Detect from project |
| `--output` | Output file path | Auto-generate from AC ID |
| `--overwrite` | Overwrite existing test file | false |
| `--verbose` | Show detailed generation log | false |

---

## Generation Logic

### 1. Parse Acceptance Criteria

```python
def parse_ac(ac_content):
    ac = {
        'id': extract_ac_id(ac_content),
        'title': extract_title(ac_content),
        'priority': extract_priority(ac_content),
        'linked_req': extract_linked_req(ac_content),
        'given': [],
        'when': [],
        'then': [],
        'and': []
    }

    lines = ac_content.split('\n')
    current_section = None

    for line in lines:
        if line.startswith('Given:'):
            current_section = 'given'
            ac['given'].append(line[6:].strip())
        elif line.startswith('When:'):
            current_section = 'when'
            ac['when'].append(line[5:].strip())
        elif line.startswith('Then:'):
            current_section = 'then'
            ac['then'].append(line[5:].strip())
        elif line.startswith('And:'):
            ac[current_section].append(line[4:].strip())

    return ac
```

### 2. Select Template

```python
def select_test_template(language, framework):
    templates = {
        ('typescript', 'jest'): 'templates/test-stubs/typescript-jest.template',
        ('typescript', 'vitest'): 'templates/test-stubs/typescript-vitest.template',
        ('python', 'pytest'): 'templates/test-stubs/python-pytest.template',
        ('java', 'junit'): 'templates/test-stubs/java-junit.template',
        ('go', 'testify'): 'templates/test-stubs/go-testify.template',
        ('rust', 'cargo-test'): 'templates/test-stubs/rust-cargo.template',
    }

    return load_template(templates.get((language, framework)))
```

### 3. Generate Test Structure

```python
def generate_test_stub(ac, template):
    test_code = template

    # Replace placeholders
    test_code = test_code.replace('{{AC_ID}}', ac['id'])
    test_code = test_code.replace('{{AC_TITLE}}', ac['title'])
    test_code = test_code.replace('{{DATE}}', datetime.now().isoformat())

    # Generate test case
    test_case = generate_test_case(ac, template.language)
    test_code = test_code.replace('{{TEST_CASES}}', test_case)

    return test_code

def generate_test_case(ac, language):
    # Generate Given section
    given_comments = [
        f"// Given: {clause}" for clause in ac['given']
    ]

    # Generate When section
    when_comments = [
        f"// When: {clause}" for clause in ac['when']
    ]

    # Generate Then section
    then_assertions = []
    for clause in ac['then']:
        assertion = generate_assertion(clause, language)
        then_assertions.append(f"// Then: {clause}\n{assertion}")

    # Generate And section
    and_assertions = []
    for clause in ac['and']:
        assertion = generate_assertion(clause, language)
        and_assertions.append(f"// And: {clause}\n{assertion}")

    return assemble_test_case(
        given_comments,
        when_comments,
        then_assertions,
        and_assertions
    )
```

### 4. Infer Test Logic

**Pattern Matching for Common Scenarios:**

| AC Phrase | Inferred Assertion |
|-----------|-------------------|
| "redirected to [URL]" | `expect(response.headers.location).toBe('[URL]')` |
| "status code [N]" | `expect(response.status).toBe([N])` |
| "cookie is set" | `expect(response.headers['set-cookie']).toBeDefined()` |
| "error message [MSG]" | `expect(response.body.error).toContain('[MSG]')` |
| "database record created" | `// TODO: Query DB and verify record exists` |
| "email sent" | `// TODO: Verify email sent via mock` |
| "timestamp updated" | `// TODO: Verify timestamp is recent` |

---

## Language-Specific Templates

### TypeScript + Jest

```typescript
// Template: templates/test-stubs/typescript-jest.template
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';

describe('{{AC_ID}}: {{AC_TITLE}}', () => {
  beforeEach(() => {
    // TODO: Setup test fixtures
  });

  afterEach(() => {
    // TODO: Cleanup test data
  });

  {{TEST_CASES}}
});
```

### Python + pytest

```python
# Template: templates/test-stubs/python-pytest.template
import pytest

class Test{{AC_ID_SAFE}}:
    """{{AC_TITLE}}"""

    @pytest.fixture(autouse=True)
    def setup(self):
        # TODO: Setup test fixtures
        yield
        # TODO: Cleanup test data

    {{TEST_CASES}}
```

### Java + JUnit

```java
// Template: templates/test-stubs/java-junit.template
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

@DisplayName("{{AC_ID}}: {{AC_TITLE}}")
public class {{TEST_CLASS_NAME}} {

    @BeforeEach
    void setup() {
        // TODO: Setup test fixtures
    }

    @AfterEach
    void teardown() {
        // TODO: Cleanup test data
    }

    {{TEST_CASES}}
}
```

---

## Examples

### Example 1: Simple AC â†’ Test Stub

**Input AC:**

```markdown
## AC-2.3: User logout

Given: User is authenticated
When: User clicks logout button
Then: User is redirected to login page
And: Session cookie is deleted
```

**Command:**

```bash
/generate test AC-2.3 --language=typescript --framework=jest
```

**Output:**

```typescript
// tests/auth/logout.test.ts
describe('AC-2.3: User logout', () => {
  it('clears session and redirects on logout', async () => {
    // Given: User is authenticated
    const authenticatedSession = {
      // TODO: Create authenticated session
    };

    // When: User clicks logout button
    const response = await request(app)
      .post('/api/logout')
      .set('Cookie', authenticatedSession.cookie);

    // Then: User is redirected to login page
    expect(response.status).toBe(302);
    expect(response.headers.location).toBe('/login');
    // TODO: Verify redirect

    // And: Session cookie is deleted
    expect(response.headers['set-cookie'][0]).toContain('session=; Max-Age=0');
    // TODO: Verify cookie deletion
  });
});
```

### Example 2: Complex AC with Multiple Assertions

**Input AC:**

```markdown
## AC-3.1: Product search with filters

Given: User is on products page
And: At least 100 products exist in database
When: User searches for "laptop"
And: User applies price filter "$500-$1000"
And: User applies brand filter "Dell, HP"
Then: Results show only matching products
And: Results are paginated (20 per page)
And: Total count is displayed
And: Filters are preserved in URL
```

**Command:**

```bash
/generate test AC-3.1 --language=python --framework=pytest
```

**Output:**

```python
# tests/products/test_search.py
import pytest

class TestAC31:
    """AC-3.1: Product search with filters"""

    @pytest.fixture(autouse=True)
    def setup(self, test_db):
        # TODO: Create 100+ test products
        # TODO: Include products matching search criteria
        # TODO: Include products not matching criteria
        yield
        # TODO: Cleanup test products

    def test_product_search_with_filters(self, client):
        # Given: User is on products page
        # And: At least 100 products exist in database
        # TODO: Verify product count in DB >= 100

        # When: User searches for "laptop"
        # And: User applies price filter "$500-$1000"
        # And: User applies brand filter "Dell, HP"
        response = client.get('/api/products', query_string={
            'search': 'laptop',
            'price_min': 500,
            'price_max': 1000,
            'brands': 'Dell,HP'
        })

        # Then: Results show only matching products
        assert response.status_code == 200
        results = response.json['products']
        for product in results:
            # TODO: Verify product matches search criteria
            assert 'laptop' in product['name'].lower()
            assert 500 <= product['price'] <= 1000
            assert product['brand'] in ['Dell', 'HP']

        # And: Results are paginated (20 per page)
        assert len(results) <= 20
        assert 'pagination' in response.json
        # TODO: Verify pagination metadata

        # And: Total count is displayed
        assert 'total_count' in response.json
        # TODO: Verify count is accurate

        # And: Filters are preserved in URL
        # TODO: Verify filter params in response URL or metadata
```

---

## Integration with CodeMaestro Workflow

### Phase 2: Planning

**After creating acceptance criteria:**

```bash
# In blueprint
AC-1.2 defined â†’ Automatically note: "Test stub can be generated"
```

### Phase 3: Implementation

**When starting task implementation:**

```bash
/next

Task T-2.1.3: Implement user authentication API
Linked ACs: AC-1.2, AC-1.3, AC-1.4

ðŸ’¡ Generate test stubs? (y/n) y

Generating test stubs for:
- AC-1.2 â†’ tests/auth/login.test.ts
- AC-1.3 â†’ tests/auth/logout.test.ts
- AC-1.4 â†’ tests/auth/password-reset.test.ts

âœ… 3 test stubs generated
ðŸ“ Implement TODOs to complete tests
```

**Developer workflow:**

1. Test stubs generated with proper structure
2. Developer implements TODOs
3. Run tests: `npm test`
4. Iterate until all pass
5. Complete task with 100% AC coverage

---

## Benefits

### 1. Faster Test Implementation
- Skip boilerplate writing
- Focus on test logic
- Consistent structure

### 2. 100% AC Coverage
- One test per AC guaranteed
- All Given/When/Then/And clauses represented
- No forgotten assertions

### 3. Clear Traceability
- AC ID in test file name and description
- Given/When/Then structure preserved
- Easy to verify ACâ†’Test mapping

### 4. Consistent Quality
- Same structure across all tests
- Team-wide consistency
- Best practices baked in

### 5. Reduced Errors
- No manual translation mistakes
- Proper assertion patterns
- Setup/teardown included

---

## Limitations & Mitigation

### Limitation 1: Cannot Infer Complex Logic

**Issue:** Generator cannot infer complex test logic from AC

**Example:**
```markdown
Then: User's credit score is recalculated
```

**Generated (limited):**
```typescript
// Then: User's credit score is recalculated
// TODO: Verify credit score recalculation logic
```

**Mitigation:** Developer implements TODO with domain logic

---

### Limitation 2: Language/Framework Detection

**Issue:** May not detect correct language/framework for multi-language projects

**Mitigation:** Allow explicit `--language` and `--framework` flags

---

### Limitation 3: Test Data Setup

**Issue:** Cannot generate realistic test fixtures

**Generated:**
```typescript
const user = {
  // TODO: Use actual test fixtures
};
```

**Mitigation:** Developer replaces with actual fixtures or factory functions

---

## Function Preservation Checklist

- âœ… Generates stubs only, developers implement logic
- âœ… No existing tests modified
- âœ… Manual test writing still fully supported
- âœ… Generated tests can be edited freely
- âœ… Opt-in feature (use `/generate test` when desired)
- âœ… No breaking changes to workflow
- âœ… All TODOs marked clearly
- âœ… Generated code is valid (compiles/parses)

---

## Future Enhancements (v2.0)

### Smart Test Data Generation
- Generate realistic fixtures based on schema
- Use factory patterns (e.g., FactoryBot, Faker)
- Detect common patterns (email, phone, name)

### Advanced Logic Inference
- Use AI to infer more test logic from AC descriptions
- Analyze similar tests in codebase
- Suggest edge cases

### Multi-AC Test Generation
- Generate integration tests spanning multiple ACs
- Test AC interactions and dependencies
- End-to-end scenario generation

---

## Related Commands

- `/generate test [AC-ID]` - Generate test stub from AC
- `/generate tests --all` - Generate stubs for all ACs
- `/validate ac` - Check AC coverage (which have tests)
- `/validate tests` - Run tests and report coverage

---

**Status:** âœ… Documented
**Next Step:** Implement test stub templates and generation logic
**Integration:** Phase D completion
**Expected Impact:** 50-70% faster test implementation, 100% AC coverage
