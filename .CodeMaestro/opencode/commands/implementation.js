#!/usr/bin/env node

const { program } = require('commander');
const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');
const { execSync, spawn } = require('child_process');

const config = require('../lib/config');
const logger = require('../lib/logger');
const projectDetector = require('../lib/project');

/**
 * Implementation Agent for Phase 3
 * Provides interactive guidance for production code implementation
 */
class ImplementationAgent {
  constructor() {
    this.projectConfig = null;
    this.implementationDir = null;
    this.specsDir = null;
    this.planningDir = null;
  }

  async initialize() {
    this.projectConfig = await config.load();
    this.implementationDir = this.projectConfig.paths.implementation;
    this.specsDir = this.projectConfig.paths.specs || this.projectConfig.paths.specifications;
    this.planningDir = this.projectConfig.paths.planning;
    await fs.ensureDir(this.implementationDir);
  }

  /**
   * Interactive question asking (simulates ask-user-questions-mcp)
   */
  async askQuestion(question, options = {}) {
    const {
      required = true,
      defaultValue = '',
      validate = null,
      hint = '',
      multiple = false,
      example = ''
    } = options;

    console.log('');
    console.log(chalk.bold.blue('â“ ' + question));

    if (hint) {
      console.log(chalk.gray('   ðŸ’¡ ' + hint));
    }

    if (example) {
      console.log(chalk.gray('   ðŸ“ Example: ' + example));
    }

    if (defaultValue) {
      console.log(chalk.gray(`   Default: ${defaultValue}`));
    }

    // In a real implementation, this would use the MCP ask-user-questions tool
    // For now, return a mock response
    return defaultValue || 'Mock response for testing';
  }

  /**
   * Multiple choice question asking
   */
  async askMultipleChoice(question, options) {
    console.log('');
    console.log(chalk.bold.blue('â“ ' + question));
    console.log(chalk.gray('   Choose from:'));
    options.forEach((option, index) => {
      console.log(chalk.gray(`   ${index + 1}. ${option.label || option}`));
      if (option.description) {
        console.log(chalk.gray(`      ${option.description}`));
      }
    });

    // In a real implementation, this would use the MCP ask-user-questions tool
    // For now, return the first option
    return options[0]?.label || options[0] || 'Mock selection';
  }

  /**
   * Validate that we're in the correct phase
   */
  async validatePhase() {
    const status = await projectDetector.getProjectStatus();
    return status.phase === 3;
  }

  /**
   * Generate code structure from blueprint
   */
  async generateCodeStructure(blueprint) {
    const structure = {
      frontend: [],
      backend: [],
      database: [],
      infrastructure: []
    };

    // Generate frontend structure
    if (blueprint.frontend?.toLowerCase().includes('react')) {
      structure.frontend = [
        'src/components/',
        'src/pages/',
        'src/hooks/',
        'src/utils/',
        'src/styles/',
        'public/'
      ];
    }

    // Generate backend structure
    if (blueprint.backend?.toLowerCase().includes('node')) {
      structure.backend = [
        'src/routes/',
        'src/controllers/',
        'src/models/',
        'src/middleware/',
        'src/services/',
        'src/utils/'
      ];
    }

    // Generate database structure
    if (blueprint.database?.toLowerCase().includes('postgres')) {
      structure.database = [
        'db/migrations/',
        'db/seeds/',
        'src/models/',
        'src/queries/'
      ];
    }

    // Generate infrastructure structure
    if (blueprint.infrastructure) {
      structure.infrastructure = [
        'infrastructure/docker/',
        'infrastructure/k8s/',
        'infrastructure/ci-cd/',
        'scripts/deploy/'
      ];
    }

    return structure;
  }

  /**
   * Create code generation template
   */
  async createCodeGenerationTemplate() {
    const content = `# Code Generation Guide

## Architecture Overview

*Generated by CodeMaestro Implementation Agent*

### Frontend Architecture
- Component Structure: [To be defined]
- State Management: [To be defined]
- Routing: [To be defined]

### Backend Architecture
- API Structure: [To be defined]
- Database Layer: [To be defined]
- Authentication: [To be defined]

### Infrastructure
- Deployment: [To be defined]
- Monitoring: [To be defined]
- CI/CD: [To be defined]

## Code Structure

\`\`\`
project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/     # Reusable UI components
â”‚   â”œâ”€â”€ pages/         # Page-level components
â”‚   â”œâ”€â”€ services/      # API and external service integrations
â”‚   â”œâ”€â”€ utils/         # Utility functions and helpers
â”‚   â”œâ”€â”€ hooks/         # Custom React hooks
â”‚   â””â”€â”€ styles/        # Styling files
â”œâ”€â”€ tests/             # Test files
â”œâ”€â”€ docs/              # Documentation
â””â”€â”€ scripts/           # Build and deployment scripts
\`\`\`

## Quality Gates

### Code Quality
- ESLint: Zero errors, minimal warnings
- Prettier: Consistent formatting
- TypeScript: Strict type checking (if applicable)

### Testing Standards
- Unit Tests: â‰¥80% coverage
- Integration Tests: Critical paths covered
- E2E Tests: User journeys validated

### Security Requirements
- Input validation on all user inputs
- Authentication for protected routes
- HTTPS everywhere
- Secure dependency management

### Performance Benchmarks
- First Contentful Paint: <1.5s
- Time to Interactive: <3s
- Lighthouse Score: â‰¥90

## Progress Tracking

### Current Sprint
- [ ] Task 1: Description
- [ ] Task 2: Description
- [ ] Task 3: Description

### Completed Features
- [x] Feature 1: Completed
- [x] Feature 2: Completed

## Token Management

### Budget Allocation
- Planning Phase: 2,000 tokens
- Implementation Phase: 12,000 tokens
- Testing Phase: 3,000 tokens
- Deployment Phase: 1,000 tokens
- **Total Budget: 18,000 tokens**

### Current Usage
- Used: 0 tokens
- Remaining: 18,000 tokens
- Efficiency: 0%

## Best Practices

### Code Organization
- Single Responsibility Principle
- DRY (Don't Repeat Yourself)
- Clean Code principles
- Consistent naming conventions

### Error Handling
- Try-catch blocks for async operations
- Proper error messages
- Logging for debugging
- Graceful degradation

### Documentation
- Inline code comments for complex logic
- README files for modules
- API documentation
- User guides

---

*Generated by CodeMaestro Implementation Agent on ${new Date().toISOString().split('T')[0]}*
`;

    return content;
  }

  /**
   * Run quality gates on generated code
   */
  async runQualityGates(filePath, codeContent) {
    const results = {
      linting: { passed: false, errors: [], error: null },
      testing: { passed: false, coverage: 0, error: null },
      security: { passed: false, vulnerabilities: [], error: null },
      overall: false
    };

    try {
      // Run linting
      results.linting = await this.runLinter(filePath, codeContent);
    } catch (error) {
      results.linting.error = error.message;
      logger.error('Linting failed:', error);
    }

    try {
      // Run tests (simplified for this implementation)
      results.testing = await this.runTests(path.dirname(filePath));
    } catch (error) {
      results.testing.error = error.message;
      logger.error('Testing failed:', error);
    }

    try {
      // Run security scan
      results.security = await this.runSecurityScan(path.dirname(filePath));
    } catch (error) {
      results.security.error = error.message;
      logger.error('Security scan failed:', error);
    }

    // Overall result
    results.overall = results.linting.passed &&
                     results.testing.passed &&
                     results.security.passed;

    return results;
  }

  /**
   * Run ESLint on code
   */
  async runLinter(filePath, codeContent) {
    try {
      // First write the code to a temporary file if it doesn't exist
      const tempDir = path.join(process.cwd(), '.temp-lint');
      await fs.ensureDir(tempDir);
      const tempFile = path.join(tempDir, path.basename(filePath));
      await fs.writeFile(tempFile, codeContent);

      // Run ESLint on the file
      const eslintCmd = `npx eslint "${tempFile}" --format=json`;
      const result = execSync(eslintCmd, { encoding: 'utf8', stdio: 'pipe' });

      // Parse ESLint JSON output
      const eslintResults = JSON.parse(result || '[]');

      // Clean up temp file
      await fs.remove(tempDir);

      // Extract errors and warnings
      const errors = [];
      let hasErrors = false;

      if (eslintResults.length > 0) {
        eslintResults[0].messages.forEach(message => {
          if (message.severity === 2) { // Error
            hasErrors = true;
            errors.push(`${message.line}:${message.column} ${message.message} (${message.ruleId})`);
          }
        });
      }

      return {
        passed: !hasErrors,
        errors: errors,
        warnings: eslintResults[0]?.messages.filter(m => m.severity === 1).length || 0
      };
    } catch (error) {
      // ESLint command failed or returned errors
      try {
        const eslintResults = JSON.parse(error.stdout || '[]');
        const errors = [];
        let hasErrors = false;

        if (eslintResults.length > 0) {
          eslintResults[0].messages.forEach(message => {
            if (message.severity === 2) {
              hasErrors = true;
              errors.push(`${message.line}:${message.column} ${message.message} (${message.ruleId})`);
            }
          });
        }

        return {
          passed: !hasErrors,
          errors: errors,
          warnings: eslintResults[0]?.messages.filter(m => m.severity === 1).length || 0
        };
      } catch (parseError) {
        // Fallback for non-JSON output
        return {
          passed: false,
          errors: ['ESLint execution failed'],
          error: error.message
        };
      }
    }
  }

  /**
   * Run tests
   */
  async runTests(projectPath) {
    try {
      const startTime = Date.now();

      // Run Jest tests with coverage
      const jestCmd = `npm test -- --coverage --coverageDirectory=.temp-coverage --testPathPattern="${path.basename(projectPath)}"`;
      const result = execSync(jestCmd, {
        cwd: path.dirname(projectPath),
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const duration = Date.now() - startTime;

      // Parse coverage from the output (simplified)
      let coverage = 0;
      const coverageMatch = result.match(/All files[^â”‚]*â”‚[^â”‚]*â”‚[^â”‚]*â”‚[^â”‚]*â”‚\s*(\d+)%/);
      if (coverageMatch) {
        coverage = parseInt(coverageMatch[1]);
      }

      // Check if tests passed
      const passed = !result.includes('FAILED') && result.includes('PASS');

      // Clean up coverage directory
      try {
        await fs.remove(path.join(path.dirname(projectPath), '.temp-coverage'));
      } catch (e) {
        // Ignore cleanup errors
      }

      return {
        passed: passed,
        coverage: coverage,
        duration: duration
      };
    } catch (error) {
      // Tests failed or Jest not available
      return {
        passed: false,
        coverage: 0,
        duration: 0,
        error: error.message
      };
    }
  }

  /**
   * Run security scan
   */
  async runSecurityScan(projectPath) {
    const vulnerabilities = [];
    let score = 100;

    try {
      // Read package.json to check dependencies
      const packageJsonPath = path.join(projectPath, 'package.json');
      if (await fs.pathExists(packageJsonPath)) {
        const packageJson = await fs.readJson(packageJsonPath);

        // Check for known vulnerable packages (simplified check)
        const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

        // Flag old versions of common vulnerable packages
        if (allDeps['express'] && allDeps['express'].startsWith('3.')) {
          vulnerabilities.push({
            package: 'express',
            version: allDeps['express'],
            severity: 'high',
            description: 'Express 3.x has known security vulnerabilities'
          });
          score -= 20;
        }

        if (allDeps['lodash'] && allDeps['lodash'].startsWith('3.')) {
          vulnerabilities.push({
            package: 'lodash',
            version: allDeps['lodash'],
            severity: 'medium',
            description: 'Lodash 3.x has known security issues'
          });
          score -= 10;
        }
      }

      // Scan source files for common security issues
      const scanFiles = async (dir) => {
        const files = await fs.readdir(dir);
        for (const file of files) {
          const filePath = path.join(dir, file);
          const stat = await fs.stat(filePath);

          if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
            await scanFiles(filePath);
          } else if (file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.jsx') || file.endsWith('.tsx')) {
            const content = await fs.readFile(filePath, 'utf-8');

            // Check for common security issues
            if (content.includes('eval(')) {
              vulnerabilities.push({
                file: path.relative(projectPath, filePath),
                issue: 'eval() usage',
                severity: 'high',
                description: 'Use of eval() can lead to code injection vulnerabilities'
              });
              score -= 15;
            }

            if (content.includes('innerHTML') && content.includes('=') && !content.includes('sanitize')) {
              vulnerabilities.push({
                file: path.relative(projectPath, filePath),
                issue: 'innerHTML assignment',
                severity: 'medium',
                description: 'Direct innerHTML assignment without sanitization'
              });
              score -= 10;
            }

            if (content.includes('console.log') && content.includes('password')) {
              vulnerabilities.push({
                file: path.relative(projectPath, filePath),
                issue: 'password logging',
                severity: 'medium',
                description: 'Potential logging of sensitive password data'
              });
              score -= 10;
            }
          }
        }
      };

      await scanFiles(projectPath);

      // Ensure score doesn't go below 0
      score = Math.max(0, score);

      return {
        passed: vulnerabilities.filter(v => v.severity === 'high').length === 0,
        vulnerabilities: vulnerabilities,
        score: score
      };
    } catch (error) {
      return {
        passed: false,
        vulnerabilities: [],
        score: 0,
        error: error.message
      };
    }
  }

  /**
   * Load existing progress from documents
   */
  async loadExistingProgress() {
    try {
      const progressFiles = await fs.readdir(this.implementationDir);
      const progressFile = progressFiles.find(file => file.includes('progress'));

      if (!progressFile) {
        return {
          tasks: [],
          overallProgress: 0,
          tokenUsage: 0,
          lastUpdated: null
        };
      }

      const progressPath = path.join(this.implementationDir, progressFile);
      const content = await fs.readFile(progressPath, 'utf-8');

      // Parse progress information (simplified parsing)
      const progress = {
        tasks: [],
        overallProgress: 0,
        tokenUsage: 0,
        lastUpdated: new Date().toISOString()
      };

      // Extract task status from markdown
      const taskMatches = content.match(/- \[([x ])\] (.+)/g);
      if (taskMatches) {
        taskMatches.forEach(match => {
          const completed = match.startsWith('- [x]');
          const taskName = match.substring(6).trim();
          progress.tasks.push({
            name: taskName,
            completed: completed,
            status: completed ? 'completed' : 'pending'
          });
        });
      }

      // Calculate overall progress
      if (progress.tasks.length > 0) {
        const completedTasks = progress.tasks.filter(t => t.completed).length;
        progress.overallProgress = Math.round((completedTasks / progress.tasks.length) * 100);
      }

      // Extract token usage (if available)
      const tokenMatch = content.match(/Token Usage: (\d+)/);
      if (tokenMatch) {
        progress.tokenUsage = parseInt(tokenMatch[1]);
      }

      return progress;
    } catch (error) {
      logger.warn('Could not load existing progress:', error.message);
      return {
        tasks: [],
        overallProgress: 0,
        tokenUsage: 0,
        lastUpdated: null
      };
    }
  }

  /**
   * Update implementation progress
   */
  async updateProgress(taskId, status, notes = '') {
    const progress = {
      taskId,
      status,
      timestamp: new Date().toISOString(),
      notes
    };

    // Load existing progress
    const existingProgress = await this.loadExistingProgress();

    // Update task status
    const taskIndex = existingProgress.tasks.findIndex(t => t.id === taskId || t.name.includes(taskId));
    if (taskIndex >= 0) {
      existingProgress.tasks[taskIndex].status = status;
      existingProgress.tasks[taskIndex].completed = status === 'completed';
      existingProgress.tasks[taskIndex].lastUpdated = progress.timestamp;
      if (notes) {
        existingProgress.tasks[taskIndex].notes = notes;
      }
    } else {
      // Add new task
      existingProgress.tasks.push({
        id: taskId,
        name: taskId,
        status: status,
        completed: status === 'completed',
        lastUpdated: progress.timestamp,
        notes: notes
      });
    }

    // Recalculate overall progress
    const completedTasks = existingProgress.tasks.filter(t => t.completed).length;
    existingProgress.overallProgress = existingProgress.tasks.length > 0
      ? Math.round((completedTasks / existingProgress.tasks.length) * 100)
      : 0;

    existingProgress.lastUpdated = progress.timestamp;

    // Save updated progress
    await this.saveProgressDocument(existingProgress);

    logger.info(`Progress updated for ${taskId}: ${status}`);

    return progress;
  }

  /**
   * Save progress document
   */
  async saveProgressDocument(progress) {
    const content = await this.createProgressTemplate();

    // Update the template with current progress
    let updatedContent = content;

    // Update overall progress
    updatedContent = updatedContent.replace(
      /Overall Progress: \d+%/,
      `Overall Progress: ${progress.overallProgress}%`
    );

    // Update task statuses
    progress.tasks.forEach(task => {
      const checkbox = task.completed ? '[x]' : '[ ]';
      const taskPattern = new RegExp(`- \\[([x ])\\] ${task.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'g');
      updatedContent = updatedContent.replace(taskPattern, `- ${checkbox} ${task.name}`);
    });

    const progressPath = await this.saveDocument('implementation-progress.md', updatedContent);
    return progressPath;
  }

  /**
   * Track token usage for code generation
   */
  async trackTokenUsage(operation, tokensUsed, details = '') {
    const existingProgress = await this.loadExistingProgress();
    existingProgress.tokenUsage += tokensUsed;

    // Add token tracking entry
    if (!existingProgress.tokenHistory) {
      existingProgress.tokenHistory = [];
    }

    existingProgress.tokenHistory.push({
      operation,
      tokens: tokensUsed,
      timestamp: new Date().toISOString(),
      details
    });

    // Save updated progress
    await this.saveProgressDocument(existingProgress);

    logger.info(`Token usage tracked: ${operation} (${tokensUsed} tokens)`);

    return existingProgress.tokenUsage;
  }

  /**
   * Generate incremental development plan
   */
  async generateIncrementalPlan(requirements, blueprint) {
    const plan = {
      phases: [],
      estimatedDuration: 0,
      riskLevel: 'Low'
    };

    // Phase 1: Foundation (Week 1)
    plan.phases.push({
      name: 'Foundation',
      duration: 7, // days
      tasks: [
        'Set up project structure',
        'Configure build tools',
        'Set up testing framework',
        'Create basic folder structure'
      ],
      deliverables: [
        'Project initialized',
        'Build pipeline working',
        'Basic tests passing'
      ]
    });

    // Phase 2: Core Implementation (Weeks 2-3)
    const coreTasks = [];
    if (blueprint.backend) {
      coreTasks.push('Implement API endpoints', 'Set up database models');
    }
    if (blueprint.frontend) {
      coreTasks.push('Create main UI components', 'Implement routing');
    }

    plan.phases.push({
      name: 'Core Implementation',
      duration: 14,
      tasks: coreTasks,
      deliverables: [
        'Core functionality working',
        'Basic user flows complete',
        'API endpoints functional'
      ]
    });

    // Phase 3: Enhancement & Quality (Week 4)
    plan.phases.push({
      name: 'Enhancement & Quality',
      duration: 7,
      tasks: [
        'Add error handling',
        'Implement security measures',
        'Add comprehensive tests',
        'Performance optimization'
      ],
      deliverables: [
        'All requirements met',
        'Quality gates passing',
        'Ready for deployment'
      ]
    });

    // Calculate total duration
    plan.estimatedDuration = plan.phases.reduce((total, phase) => total + phase.duration, 0);

    // Assess risk level based on requirements and blueprint
    if (requirements.length > 10) {
      plan.riskLevel = 'Medium';
    }
    if (blueprint.frontend && blueprint.backend && blueprint.database) {
      plan.riskLevel = plan.riskLevel === 'Medium' ? 'High' : 'Medium';
    }

    return plan;
  }

  /**
   * Estimate implementation tokens
   */
  async estimateImplementationTokens(blueprint, tasks) {
    let totalTokens = 0;
    const estimates = {
      frontendTokens: 0,
      backendTokens: 0,
      databaseTokens: 0,
      infrastructureTokens: 0,
      total: 0
    };

    // Base token calculation per component
    if (blueprint.frontend) {
      estimates.frontendTokens = 4000; // Base for React/Vue/Angular setup
      totalTokens += estimates.frontendTokens;
    }

    if (blueprint.backend) {
      estimates.backendTokens = 5000; // Base for Node/Express/Python setup
      totalTokens += estimates.backendTokens;
    }

    if (blueprint.database) {
      estimates.databaseTokens = 2000; // Base for database setup
      totalTokens += estimates.databaseTokens;
    }

    if (blueprint.infrastructure) {
      estimates.infrastructureTokens = 2000; // Base for deployment setup
      totalTokens += estimates.infrastructureTokens;
    }

    // Adjust based on task complexity
    const complexityMultiplier = {
      'Low': 0.8,
      'Medium': 1.0,
      'High': 1.3
    };

    tasks.forEach(task => {
      const multiplier = complexityMultiplier[task.complexity] || 1.0;
      totalTokens = Math.round(totalTokens * multiplier);
    });

    estimates.total = totalTokens;

    return estimates;
  }

  /**
   * Save generated code to file system
   */
  async saveGeneratedCode(filePath, codeContent) {
    const fullPath = path.join(process.cwd(), filePath);
    await fs.ensureDir(path.dirname(fullPath));
    await fs.writeFile(fullPath, codeContent);
    return fullPath;
  }

  /**
   * List existing implementation documents
   */
  async listExistingDocuments() {
    try {
      const files = await fs.readdir(this.implementationDir);
      return files.filter(file => file.endsWith('.md'));
    } catch (error) {
      return [];
    }
  }

  /**
   * Save document to implementation directory
   */
  async saveDocument(filename, content) {
    const filePath = path.join(this.implementationDir, filename);
    await fs.writeFile(filePath, content);
    return filePath;
  }

  /**
   * Gather implementation preferences
   */
  async gatherImplementationPreferences() {
    const codingStyle = await this.askMultipleChoice(
      'What is your preferred coding style?',
      [
        { label: 'Functional Programming', description: 'Emphasizes pure functions and immutability' },
        { label: 'Object-Oriented Programming', description: 'Uses classes and inheritance' },
        { label: 'Procedural Programming', description: 'Uses procedures and global state' }
      ]
    );

    const testingFramework = await this.askQuestion(
      'What testing framework do you prefer?',
      {
        defaultValue: 'Jest',
        hint: 'Common options: Jest, Mocha, Jasmine, Vitest',
        example: 'Jest for React/Node.js projects'
      }
    );

    const documentation = await this.askQuestion(
      'How much documentation do you want generated?',
      {
        defaultValue: 'Moderate',
        hint: 'Options: Minimal, Moderate, Comprehensive',
        example: 'Moderate - READMEs and key function docs'
      }
    );

    return {
      codingStyle,
      testingFramework,
      documentation
    };
  }

  /**
   * Gather code generation constraints
   */
  async gatherCodeConstraints() {
    const performance = await this.askQuestion(
      'What performance requirements do you have?',
      {
        hint: 'Response time, throughput, scalability needs',
        example: 'Page load <2s, API response <500ms'
      }
    );

    const security = await this.askQuestion(
      'What security requirements must be met?',
      {
        hint: 'Authentication, authorization, data protection',
        example: 'JWT auth, input validation, HTTPS'
      }
    );

    const maintainability = await this.askQuestion(
      'What maintainability standards should be followed?',
      {
        hint: 'Code quality, documentation, testing coverage',
        example: 'ESLint, 80% test coverage, TypeScript'
      }
    );

    return {
      performance,
      security,
      maintainability
    };
  }

  /**
   * Load blueprint from existing planning documents
   */
  async loadBlueprintFromPlanning() {
    try {
      const planningFiles = await fs.readdir(this.planningDir);
      const blueprintFile = planningFiles.find(file => file.includes('blueprint'));

      if (!blueprintFile) {
        return null;
      }

      const blueprintPath = path.join(this.planningDir, blueprintFile);
      const content = await fs.readFile(blueprintPath, 'utf-8');

      // Parse blueprint information (simplified parsing)
      const blueprint = {};

      if (content.includes('React.js') || content.includes('Vue.js')) {
        blueprint.frontend = 'React.js';
      }
      if (content.includes('Node.js') || content.includes('Express')) {
        blueprint.backend = 'Node.js/Express';
      }
      if (content.includes('PostgreSQL') || content.includes('MongoDB')) {
        blueprint.database = content.includes('PostgreSQL') ? 'PostgreSQL' : 'MongoDB';
      }

      return blueprint;
    } catch (error) {
      logger.warn('Could not load blueprint from planning documents:', error.message);
      return null;
    }
  }

  /**
   * Load requirements from specifications
   */
  async loadRequirementsFromSpecs() {
    try {
      const specFiles = await fs.readdir(this.specsDir);
      const specFile = specFiles.find(file => file.includes('spec'));

      if (!specFile) {
        return null;
      }

      const specPath = path.join(this.specsDir, specFile);
      const content = await fs.readFile(specPath, 'utf-8');

      // Extract key requirements (simplified parsing)
      const requirements = [];

      // Look for functional requirements section
      const functionalMatch = content.match(/### Functional Requirements\s*\n([\s\S]*?)(?=\n###|\n##|$)/);
      if (functionalMatch) {
        const functionalReqs = functionalMatch[1].split('\n').filter(line =>
          line.trim().startsWith('-') || line.trim().startsWith('*')
        );
        requirements.push(...functionalReqs.map(req => req.trim().substring(1).trim()));
      }

      return requirements.length > 0 ? requirements : null;
    } catch (error) {
      logger.warn('Could not load requirements from specifications:', error.message);
      return null;
    }
  }

  /**
   * Interactive code generation workflow
   */
  async runInteractiveCodeGeneration() {
    console.log(chalk.bold.cyan('ðŸ”§ Interactive Code Generation'));
    console.log('This wizard will help you generate production-ready code based on your requirements.');
    console.log('');

    // Load existing blueprint and requirements
    console.log(chalk.blue('ðŸ“‚ Loading project context...'));
    const blueprint = await this.loadBlueprintFromPlanning();
    const requirements = await this.loadRequirementsFromSpecs();

    if (blueprint) {
      console.log(chalk.green('âœ… Found existing blueprint:'));
      console.log(chalk.gray(`   Frontend: ${blueprint.frontend || 'Not specified'}`));
      console.log(chalk.gray(`   Backend: ${blueprint.backend || 'Not specified'}`));
      console.log(chalk.gray(`   Database: ${blueprint.database || 'Not specified'}`));
    } else {
      console.log(chalk.yellow('âš ï¸  No blueprint found. Please run planning first.'));
      console.log(chalk.gray('   Use: /codem-planning blueprint --interactive'));
      return;
    }

    if (requirements && requirements.length > 0) {
      console.log(chalk.green(`âœ… Found ${requirements.length} requirements`));
    } else {
      console.log(chalk.yellow('âš ï¸  No requirements found. Please create specifications first.'));
      console.log(chalk.gray('   Use: /codem-requirements spec --template'));
      return;
    }

    // Gather implementation preferences
    console.log('');
    console.log(chalk.blue('âš™ï¸  Gathering implementation preferences...'));
    const preferences = await this.gatherImplementationPreferences();

    // Gather code constraints
    console.log('');
    console.log(chalk.blue('ðŸ”’ Gathering code generation constraints...'));
    const constraints = await this.gatherCodeConstraints();

    // Generate code
    console.log('');
    console.log(chalk.blue('ðŸš€ Generating code...'));

    const generatedCode = await this.generateCodeFromRequirements(
      requirements.join('; '),
      blueprint,
      preferences
    );

    // Save generated code
    console.log('');
    console.log(chalk.blue('ðŸ’¾ Saving generated code...'));

    const savedFiles = [];
    if (generatedCode.frontend) {
      const frontendPath = await this.saveGeneratedCode('src/components/GeneratedComponent.jsx', generatedCode.frontend);
      savedFiles.push(frontendPath);
    }

    if (generatedCode.backend) {
      const backendPath = await this.saveGeneratedCode('src/routes/generated.js', generatedCode.backend);
      savedFiles.push(backendPath);
    }

    if (generatedCode.database) {
      const dbPath = await this.saveGeneratedCode('src/models/generated.js', generatedCode.database);
      savedFiles.push(dbPath);
    }

    if (generatedCode.tests) {
      const testPath = await this.saveGeneratedCode('tests/generated.test.js', generatedCode.tests);
      savedFiles.push(testPath);
    }

    // Run quality gates
    console.log('');
    console.log(chalk.blue('ðŸ›¡ï¸ Running quality gates...'));

    const qualityResults = [];
    for (const filePath of savedFiles) {
      const content = await fs.readFile(filePath, 'utf-8');
      const results = await this.runQualityGates(filePath, content);
      qualityResults.push({ file: path.basename(filePath), results });
    }

    // Report results
    console.log('');
    console.log(chalk.bold.green('âœ… Code generation complete!'));
    console.log('');
    console.log(chalk.bold('Generated Files:'));
    savedFiles.forEach(file => {
      console.log(chalk.gray(`   â€¢ ${path.relative(process.cwd(), file)}`));
    });

    console.log('');
    console.log(chalk.bold('Quality Gates Results:'));
    qualityResults.forEach(({ file, results }) => {
      const status = results.overall ? chalk.green('âœ…') : chalk.red('âŒ');
      console.log(`${status} ${file}`);
      if (!results.linting.passed) {
        console.log(chalk.red(`   Linting: ${results.linting.errors.length} errors`));
      }
      if (!results.testing.passed) {
        console.log(chalk.red('   Testing: Failed'));
      }
      if (!results.security.passed) {
        console.log(chalk.red('   Security: Failed'));
      }
    });

    // Create implementation progress document
    const progressDoc = await this.createProgressTemplate();
    const progressPath = await this.saveDocument('implementation-progress.md', progressDoc);

    console.log('');
    console.log(chalk.green(`ðŸ“Š Progress tracking: ${path.relative(process.cwd(), progressPath)}`));

    console.log('');
    console.log(chalk.bold.cyan('ðŸŽ‰ Next Steps:'));
    console.log('1. Review generated code and customize as needed');
    console.log('2. Run tests: npm test');
    console.log('3. Fix any quality gate issues');
    console.log('4. Update progress: /codem-implementation progress');
  }

  /**
   * Generate code from requirements with token tracking
   */
  async generateCodeFromRequirements(requirements, blueprint, preferences) {
    const code = {
      frontend: '',
      backend: '',
      database: '',
      tests: '',
      tokenUsage: {
        frontend: 0,
        backend: 0,
        database: 0,
        tests: 0,
        total: 0
      }
    };

    const tokenBudget = await this.getTokenBudget();

    // Generate frontend code
    if (blueprint.frontend?.toLowerCase().includes('react')) {
      const frontendTokens = await this.estimateCodeTokens('frontend', requirements);
      if (this.checkTokenBudget(tokenBudget, frontendTokens)) {
        code.frontend = await this.generateComponentCode(requirements, preferences);
        code.tokenUsage.frontend = frontendTokens;
        await this.trackTokenUsage('frontend-code-generation', frontendTokens, 'React component generation');
      } else {
        console.log(chalk.yellow(`âš ï¸  Skipping frontend generation - would exceed token budget`));
      }
    }

    // Generate backend code
    if (blueprint.backend?.toLowerCase().includes('node')) {
      const backendTokens = await this.estimateCodeTokens('backend', requirements);
      if (this.checkTokenBudget(tokenBudget, backendTokens)) {
        code.backend = await this.generateApiCode(requirements, preferences);
        code.tokenUsage.backend = backendTokens;
        await this.trackTokenUsage('backend-code-generation', backendTokens, 'Node.js API generation');
      } else {
        console.log(chalk.yellow(`âš ï¸  Skipping backend generation - would exceed token budget`));
      }
    }

    // Generate database code
    if (blueprint.database?.toLowerCase().includes('postgres')) {
      const databaseTokens = await this.estimateCodeTokens('database', requirements);
      if (this.checkTokenBudget(tokenBudget, databaseTokens)) {
        code.database = await this.generateDatabaseCode(requirements, preferences);
        code.tokenUsage.database = databaseTokens;
        await this.trackTokenUsage('database-code-generation', databaseTokens, 'PostgreSQL model generation');
      } else {
        console.log(chalk.yellow(`âš ï¸  Skipping database generation - would exceed token budget`));
      }
    }

    // Generate tests
    const testTokens = await this.estimateCodeTokens('tests', requirements);
    if (this.checkTokenBudget(tokenBudget, testTokens)) {
      code.tests = await this.generateTestCode(requirements, preferences);
      code.tokenUsage.tests = testTokens;
      await this.trackTokenUsage('test-code-generation', testTokens, 'Test suite generation');
    } else {
      console.log(chalk.yellow(`âš ï¸  Skipping test generation - would exceed token budget`));
    }

    // Calculate total
    code.tokenUsage.total = code.tokenUsage.frontend + code.tokenUsage.backend +
                           code.tokenUsage.database + code.tokenUsage.tests;

    return code;
  }

  /**
   * Get current token budget and usage
   */
  async getTokenBudget() {
    const progress = await this.loadExistingProgress();
    const estimates = await this.estimateImplementationTokens({}, []); // Get base estimates

    return {
      allocated: estimates.total,
      used: progress.tokenUsage || 0,
      remaining: Math.max(0, estimates.total - (progress.tokenUsage || 0)),
      efficiency: progress.tokenUsage ? Math.round((progress.tokenUsage / estimates.total) * 100) : 0
    };
  }

  /**
   * Check if operation fits within token budget
   */
  checkTokenBudget(budget, tokensNeeded) {
    return budget.remaining >= tokensNeeded;
  }

  /**
   * Estimate tokens needed for code generation
   */
  async estimateCodeTokens(componentType, requirements) {
    const baseTokens = {
      frontend: 1000,
      backend: 1200,
      database: 800,
      tests: 600
    };

    let tokens = baseTokens[componentType] || 500;

    // Adjust based on requirements complexity
    const reqCount = Array.isArray(requirements) ? requirements.length : requirements.split(';').length;
    tokens += reqCount * 100; // 100 tokens per requirement

    // Adjust based on component type complexity
    if (componentType === 'frontend') {
      tokens *= 1.2; // Frontend often needs more detailed code
    } else if (componentType === 'backend') {
      tokens *= 1.3; // Backend includes API logic
    }

    return Math.round(tokens);
  }

  /**
   * Optimize code generation for token efficiency
   */
  async optimizeForTokens(requirements, blueprint, preferences) {
    const budget = await this.getTokenBudget();
    const optimizations = [];

    // Prioritize based on budget
    if (budget.remaining < 2000) {
      optimizations.push('Generate minimal viable code only');
      optimizations.push('Skip advanced features and optimizations');
      optimizations.push('Use simple implementations over comprehensive ones');
    } else if (budget.remaining < 5000) {
      optimizations.push('Generate core functionality with basic error handling');
      optimizations.push('Include essential tests only');
    } else {
      optimizations.push('Generate comprehensive implementations');
      optimizations.push('Include full test coverage');
      optimizations.push('Add performance optimizations');
    }

    // Apply optimizations to preferences
    const optimizedPreferences = { ...preferences };

    if (budget.efficiency > 80) {
      optimizedPreferences.detailLevel = 'minimal';
      optimizations.push('Reduced detail level due to high token usage');
    }

    return {
      optimizedPreferences,
      optimizations,
      budget
    };
  }

  /**
   * Generate React component code
   */
  async generateComponentCode(requirements, preferences) {
    // Simplified code generation - in reality this would use AI/ML models
    return `import React, { useState, useEffect } from 'react';

const GeneratedComponent = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // ${requirements}
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      // TODO: Implement data fetching based on requirements
      setLoading(false);
    } catch (error) {
      console.error('Error fetching data:', error);
      setLoading(false);
    }
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="generated-component">
      <h2>Generated Component</h2>
      {/* TODO: Implement component based on ${requirements} */}
    </div>
  );
};

export default GeneratedComponent;
`;
  }

  /**
   * Generate API code
   */
  async generateApiCode(requirements, preferences) {
    // Simplified API generation
    return `const express = require('express');
const router = express.Router();

// ${requirements}
// TODO: Implement API endpoints based on requirements

router.get('/api/data', async (req, res) => {
  try {
    // TODO: Implement data retrieval logic
    res.json({ message: 'API endpoint generated', requirements: '${requirements}' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/api/data', async (req, res) => {
  try {
    // TODO: Implement data creation logic
    res.status(201).json({ message: 'Data created successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
`;
  }

  /**
   * Generate database code
   */
  async generateDatabaseCode(requirements, preferences) {
    // Simplified database code generation
    return `const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// ${requirements}
// TODO: Implement database operations based on requirements

const getData = async () => {
  const query = 'SELECT * FROM generated_table'; // TODO: Update based on requirements
  const result = await pool.query(query);
  return result.rows;
};

const createData = async (data) => {
  const query = 'INSERT INTO generated_table (column1) VALUES ($1) RETURNING *';
  const values = [data.value];
  const result = await pool.query(query, values);
  return result.rows[0];
};

module.exports = {
  getData,
  createData,
  pool
};
`;
  }

  /**
   * Generate test code
   */
  async generateTestCode(requirements, preferences) {
    const framework = preferences.testingFramework || 'Jest';

    if (framework.toLowerCase().includes('jest')) {
      return `const request = require('supertest');
const app = require('../app'); // Adjust path as needed

describe('${requirements}', () => {
  test('should perform basic functionality', async () => {
    // TODO: Implement tests based on requirements
    expect(true).toBe(true);
  });

  test('should handle edge cases', async () => {
    // TODO: Add edge case tests
    expect(true).toBe(true);
  });
});
`;
    }

    return `// Test code generation for ${framework}
// TODO: Implement tests based on requirements
`;
  }

  /**
   * Create progress template
   */
  async createProgressTemplate() {
    const content = `# Implementation Progress

## Current Status

*Generated by CodeMaestro Implementation Agent*

### Sprint Information
- **Current Sprint**: Sprint 1
- **Start Date**: ${new Date().toISOString().split('T')[0]}
- **End Date**: [To be determined]
- **Sprint Goal**: [To be defined]

### Progress Metrics
- **Tasks Completed**: 0 / 0
- **Code Coverage**: 0%
- **Quality Gates Passed**: 0 / 3
- **Token Usage**: 0 / 18,000

## Completed Tasks

### Sprint 1
- [x] Environment setup
- [x] Project structure created
- [x] Initial documentation

### Previous Sprints
- [x] Requirements gathering
- [x] Technical planning
- [x] Architecture design

## In Progress

### Current Tasks
- [ ] Task 1: Description
- [ ] Task 2: Description
- [ ] Task 3: Description

### Blocked Tasks
- [ ] Blocked Task: Waiting for clarification

## Next Steps

### Immediate Priorities
1. Implement core functionality
2. Set up testing framework
3. Configure CI/CD pipeline

### Sprint Planning
- Review completed work
- Plan next sprint objectives
- Update task estimates

## Blockers & Risks

### Current Blockers
- None identified

### Potential Risks
- Technology learning curve
- Third-party service dependencies
- Performance requirements

## Quality Assurance

### Code Quality
- [ ] ESLint: 0 errors
- [ ] Unit Tests: â‰¥80% coverage
- [ ] Integration Tests: Passing
- [ ] Security Scan: Passing

### Performance
- [ ] Load Testing: Completed
- [ ] Performance Benchmarks: Met
- [ ] Accessibility: WCAG 2.1 AA

---

*Last updated: ${new Date().toISOString()}*
`;

    return content;
  }

  /**
   * Create quality gates template
   */
  async createQualityGatesTemplate() {
    const content = `# Quality Gates

## Code Quality

*Generated by CodeMaestro Implementation Agent*

### Automated Checks
- **ESLint**: Zero errors, minimal warnings
- **Prettier**: Consistent code formatting
- **TypeScript**: Strict type checking enabled
- **SonarQube**: Code quality score â‰¥7/10

### Manual Reviews
- **Code Review**: Required for all PRs
- **Architecture Review**: Major changes reviewed
- **Security Review**: Authentication and data handling

## Testing Standards

### Unit Testing
- **Coverage**: â‰¥80% line coverage
- **Frameworks**: Jest, Mocha, or equivalent
- **Mocking**: External dependencies properly mocked
- **Assertions**: Clear and comprehensive

### Integration Testing
- **API Endpoints**: All endpoints tested
- **Database Operations**: CRUD operations validated
- **External Services**: Proper mocking or staging environments

### End-to-End Testing
- **Critical User Journeys**: Fully automated
- **Cross-browser Testing**: Chrome, Firefox, Safari
- **Mobile Responsiveness**: Tested on multiple devices

## Security Requirements

### Authentication & Authorization
- **JWT Tokens**: Proper validation and expiration
- **Role-based Access**: Permission levels implemented
- **Session Management**: Secure session handling

### Data Protection
- **Input Validation**: All user inputs sanitized
- **SQL Injection**: Parameterized queries used
- **XSS Prevention**: Output encoding implemented
- **CSRF Protection**: Tokens implemented for state changes

### Infrastructure Security
- **HTTPS**: All communications encrypted
- **Environment Variables**: Secrets not in code
- **Dependency Scanning**: Regular vulnerability checks
- **Container Security**: Minimal base images, no root access

## Performance Benchmarks

### Frontend Performance
- **First Contentful Paint**: <1.5 seconds
- **Largest Contentful Paint**: <2.5 seconds
- **First Input Delay**: <100 milliseconds
- **Cumulative Layout Shift**: <0.1

### Backend Performance
- **API Response Time**: <500 milliseconds (95th percentile)
- **Database Query Time**: <100 milliseconds average
- **Concurrent Users**: Support 1000+ concurrent users
- **Error Rate**: <0.1%

### Infrastructure Performance
- **Uptime**: 99.9% availability
- **Scalability**: Auto-scaling configured
- **Monitoring**: Real-time performance tracking
- **Backup Recovery**: <4 hour RTO, <1 hour RPO

## Acceptance Criteria

### Functional Requirements
- [ ] All user stories implemented
- [ ] Business logic correctly implemented
- [ ] User interface matches designs
- [ ] Data flows work end-to-end

### Non-Functional Requirements
- [ ] Performance benchmarks met
- [ ] Security requirements satisfied
- [ ] Accessibility standards met
- [ ] Browser compatibility verified

### Quality Requirements
- [ ] Code review completed
- [ ] All tests passing
- [ ] Documentation updated
- [ ] Deployment successful

---

*Quality Gates Definition - Version 1.0*
*Generated by CodeMaestro Implementation Agent*
`;

    return content;
  }
}

// Command-line interface
async function implementationCommand(action, options) {
  try {
    const agent = new ImplementationAgent();
    await agent.initialize();

    // Validate phase
    if (!(await agent.validatePhase())) {
      const status = await projectDetector.getProjectStatus();
      console.log(chalk.red(`âŒ Implementation Agent is designed for Phase 3 (Implementation)`));
      console.log(chalk.gray(`   Current phase: ${status.phase} (${status.role})`));
      console.log(chalk.yellow(`   ðŸ’¡ Use '/codem-phase 3' to advance to implementation phase`));
      return;
    }

    switch (action) {
      case 'guide':
      default:
        console.log(chalk.bold.cyan('ðŸ“‹ Phase 3 Implementation Guide'));
        console.log('');
        console.log(chalk.bold('Phase 3 Objective:'));
        console.log('  Implement production code following blueprint patterns');
        console.log('');
        console.log(chalk.bold('Available Commands:'));
        console.log('  /codem-implementation generate --interactive    Generate code from requirements');
        console.log('  /codem-implementation generate --template       Create code generation template');
        console.log('  /codem-implementation quality                  Run quality gates on codebase');
        console.log('  /codem-implementation progress                 Track implementation progress');
        console.log('  /codem-implementation estimate                 Estimate implementation tokens');
        console.log('  /codem-implementation list                     List implementation documents');
        console.log('');
        console.log(chalk.bold('Quality Gates:'));
        console.log('  â€¢ Code Quality: ESLint + TypeScript');
        console.log('  â€¢ Testing: â‰¥80% coverage');
        console.log('  â€¢ Security: Vulnerability scanning');
        console.log('  â€¢ Performance: Lighthouse â‰¥90');
        break;

      case 'generate':
        if (options.template) {
          console.log(chalk.bold.blue('ðŸ”§ Code Generation'));
          console.log('Creating code generation template...');

          const template = await agent.createCodeGenerationTemplate();
          const filePath = await agent.saveDocument('code-generation-guide.md', template);

          console.log(chalk.green('âœ… Code generation template created'));
          console.log(chalk.gray(`   ðŸ“ ${path.relative(process.cwd(), filePath)}`));
        } else if (options.interactive) {
          await agent.runInteractiveCodeGeneration();
        } else {
          console.log(chalk.yellow('Please specify --template or --interactive'));
          console.log(chalk.gray('  --template: Create code generation guide'));
          console.log(chalk.gray('  --interactive: Launch interactive code generation'));
        }
        break;

      case 'quality':
        console.log(chalk.bold.blue('ðŸ›¡ï¸ Quality Gates'));
        console.log('Running quality checks on current codebase...');

        // This would run quality gates on the actual codebase
        console.log(chalk.yellow('âš ï¸  Quality gates scanning not yet implemented in this prototype'));
        console.log(chalk.gray('   This would check: ESLint, Tests, Security, Performance'));
        break;

      case 'progress':
        console.log(chalk.bold.blue('ðŸ“Š Implementation Progress'));
        console.log('Creating progress tracking template...');

        const progressTemplate = await agent.createProgressTemplate();
        const progressPath = await agent.saveDocument('implementation-progress.md', progressTemplate);

        console.log(chalk.green('âœ… Progress tracking template created'));
        console.log(chalk.gray(`   ðŸ“ ${path.relative(process.cwd(), progressPath)}`));
        break;

      case 'estimate':
        console.log(chalk.bold.blue('ðŸª™ Token Estimation'));
        console.log('Estimating implementation token usage...');

        // Mock estimation - would use actual blueprint data
        const mockEstimates = {
          frontendTokens: 4000,
          backendTokens: 5000,
          databaseTokens: 2000,
          infrastructureTokens: 2000,
          total: 13000
        };

        console.log(chalk.green('âœ… Token estimation complete'));
        console.log(`   Frontend: ${mockEstimates.frontendTokens.toLocaleString()} tokens`);
        console.log(`   Backend: ${mockEstimates.backendTokens.toLocaleString()} tokens`);
        console.log(`   Database: ${mockEstimates.databaseTokens.toLocaleString()} tokens`);
        console.log(`   Infrastructure: ${mockEstimates.infrastructureTokens.toLocaleString()} tokens`);
        console.log(chalk.bold(`   Total: ${mockEstimates.total.toLocaleString()} tokens`));
        break;

      case 'list':
        console.log(chalk.bold.blue('ðŸ“ Existing Implementation Documents'));

        const documents = await agent.listExistingDocuments();

        if (documents.length === 0) {
          console.log(chalk.yellow('No implementation documents found'));
          console.log(chalk.gray('   Create documents using: /codem-implementation generate --template'));
        } else {
          console.log(`Found ${documents.length} document(s):`);
          documents.forEach(doc => {
            console.log(chalk.gray(`   â€¢ ${doc}`));
          });
        }
        break;
    }

  } catch (error) {
    console.error(chalk.red('âŒ Implementation command failed:'), error.message);
    logger.error('Implementation command error:', error);
  }
}

// CLI setup
program
  .name('codem-implementation')
  .description('Implementation Agent for Phase 3 - Code generation and quality assurance')
  .argument('[action]', 'Action to perform (guide, generate, quality, progress, estimate, list)')
  .option('--interactive', 'Launch interactive mode')
  .option('--template', 'Generate template instead of interactive mode')
  .action(implementationCommand);

module.exports = {
  ImplementationAgent,
  implementationCommand
};