// Mock external dependencies
jest.mock('../lib/config');
jest.mock('../lib/logger');
jest.mock('../lib/project');
jest.mock('fs-extra');

// Mock process.exit to prevent test termination
const originalExit = process.exit;
beforeAll(() => {
  process.exit = jest.fn();
});
afterAll(() => {
  process.exit = originalExit;
});

// Import the modules we want to test
const config = require('../lib/config');
const projectDetector = require('../lib/project');
const fs = require('fs-extra');

describe('Implementation Agent', () => {
  let mockAgent;

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();

    // Setup default mock implementations
    config.load.mockResolvedValue({
      paths: {
        implementation: '/mock/project/docs/implementation',
        specs: '/mock/project/docs/specifications',
        planning: '/mock/project/docs/planning'
      }
    });

    projectDetector.isCodeMaestroProject.mockResolvedValue(true);
    projectDetector.getProjectStatus.mockResolvedValue({
      phase: 3,
      task: 'Implement production code following blueprint patterns',
      role: 'Senior Developer'
    });

    fs.ensureDir.mockResolvedValue();
    fs.writeFile.mockResolvedValue();
    fs.readdir.mockResolvedValue([]);
    fs.readFile.mockResolvedValue('# Mock specification content');
  });

  describe('ImplementationAgent class', () => {
    beforeEach(async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      mockAgent = new ImplementationAgent();
      await mockAgent.initialize();
    });

    test('should initialize with correct paths', () => {
      expect(mockAgent.implementationDir).toBe('/mock/project/docs/implementation');
      expect(mockAgent.specsDir).toBe('/mock/project/docs/specifications');
      expect(mockAgent.planningDir).toBe('/mock/project/docs/planning');
    });

    test('should validate phase correctly', async () => {
      const result = await mockAgent.validatePhase();
      expect(result).toBe(true);
    });

    test('should reject invalid phase', async () => {
      projectDetector.getProjectStatus.mockResolvedValue({
        phase: 1,
        task: 'Gather requirements',
        role: 'Product Manager'
      });

      const result = await mockAgent.validatePhase();
      expect(result).toBe(false);
    });

    test('should generate code structure from blueprint', async () => {
      const blueprint = {
        frontend: 'React.js',
        backend: 'Node.js/Express',
        database: 'PostgreSQL'
      };

      const structure = await mockAgent.generateCodeStructure(blueprint);

      expect(structure).toHaveProperty('frontend');
      expect(structure).toHaveProperty('backend');
      expect(structure).toHaveProperty('database');
      expect(structure.frontend).toContain('src/components/');
      expect(structure.backend).toContain('src/routes/');
    });

    test('should create code generation template', async () => {
      const template = await mockAgent.createCodeGenerationTemplate();

      expect(template).toContain('# Code Generation Guide');
      expect(template).toContain('## Architecture Overview');
      expect(template).toContain('## Code Structure');
      expect(template).toContain('*Generated by CodeMaestro Implementation Agent*');
    });

    test('should run quality gates on generated code', async () => {
      const codeContent = 'function test() { return true; }';
      const filePath = '/mock/project/src/test.js';

      // Mock linting and testing as passing
      mockAgent.runLinter = jest.fn().mockResolvedValue({ passed: true, errors: [] });
      mockAgent.runTests = jest.fn().mockResolvedValue({ passed: true, coverage: 85 });
      mockAgent.runSecurityScan = jest.fn().mockResolvedValue({ passed: true, vulnerabilities: [] });

      const results = await mockAgent.runQualityGates(filePath, codeContent);

      expect(results.linting.passed).toBe(true);
      expect(results.testing.passed).toBe(true);
      expect(results.security.passed).toBe(true);
      expect(results.overall).toBe(true);
    });

    test('should track implementation progress', async () => {
      const taskId = 'T1';
      const status = 'completed';
      const notes = 'Task completed successfully';

      const progress = await mockAgent.updateProgress(taskId, status, notes);

      expect(progress.taskId).toBe(taskId);
      expect(progress.status).toBe(status);
      expect(progress.timestamp).toBeDefined();
      expect(progress.notes).toBe(notes);
    });

    test('should estimate implementation tokens', async () => {
      const blueprint = {
        frontend: 'React.js',
        backend: 'Node.js',
        database: 'PostgreSQL'
      };
      const tasks = [
        { id: 'T1', name: 'Setup Frontend', complexity: 'Medium' },
        { id: 'T2', name: 'Implement API', complexity: 'High' }
      ];

      const estimates = await mockAgent.estimateImplementationTokens(blueprint, tasks);

      expect(estimates.total).toBeGreaterThan(0);
      expect(estimates.frontendTokens).toBeGreaterThan(0);
      expect(estimates.backendTokens).toBeGreaterThan(0);
      expect(estimates.databaseTokens).toBeGreaterThan(0);
    });

    test('should save generated code to file system', async () => {
      const codeContent = 'console.log("Hello World");';
      const filePath = 'src/index.js';

      const fullPath = await mockAgent.saveGeneratedCode(filePath, codeContent);

      expect(fullPath).toContain('src/index.js');
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('src/index.js'),
        codeContent
      );
    });

    test('should list existing implementation documents', async () => {
      fs.readdir.mockResolvedValue(['code-structure.md', 'progress.md', 'not-md.txt']);

      const documents = await mockAgent.listExistingDocuments();

      expect(documents).toEqual(['code-structure.md', 'progress.md']);
    });
  });

  describe('Interactive code generation methods', () => {
    beforeEach(async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      mockAgent = new ImplementationAgent();
      await mockAgent.initialize();
    });

    test('should gather implementation preferences', async () => {
      mockAgent.askQuestion = jest.fn().mockResolvedValue('Test Answer');
      mockAgent.askMultipleChoice = jest.fn().mockResolvedValue('Option 1');

      const preferences = await mockAgent.gatherImplementationPreferences();

      expect(mockAgent.askMultipleChoice).toHaveBeenCalledWith(
        'What is your preferred coding style?',
        expect.any(Array)
      );
      expect(preferences).toHaveProperty('codingStyle');
      expect(preferences).toHaveProperty('testingFramework');
      expect(preferences).toHaveProperty('documentation');
    });

    test('should gather code generation constraints', async () => {
      mockAgent.askQuestion = jest.fn().mockResolvedValue('Test Answer');
      mockAgent.askMultipleChoice = jest.fn().mockResolvedValue('High');

      const constraints = await mockAgent.gatherCodeConstraints();

      expect(mockAgent.askQuestion).toHaveBeenCalledWith(
        'What performance requirements do you have?',
        expect.objectContaining({
          hint: expect.any(String)
        })
      );
      expect(constraints).toHaveProperty('performance');
      expect(constraints).toHaveProperty('security');
      expect(constraints).toHaveProperty('maintainability');
    });

    test('should generate code from requirements with token tracking', async () => {
      const requirements = 'Create a user authentication system';
      const blueprint = { frontend: 'React.js', backend: 'Node.js' };
      const preferences = { codingStyle: 'Functional', testing: 'Jest' };

      mockAgent.generateComponentCode = jest.fn().mockResolvedValue('export const Auth = () => {};');
      mockAgent.generateApiCode = jest.fn().mockResolvedValue('app.post("/auth", handler);');
      mockAgent.getTokenBudget = jest.fn().mockResolvedValue({ remaining: 10000, used: 0 });
      mockAgent.checkTokenBudget = jest.fn().mockReturnValue(true);
      mockAgent.estimateCodeTokens = jest.fn().mockResolvedValue(1000);
      mockAgent.trackTokenUsage = jest.fn().mockResolvedValue(1000);

      const code = await mockAgent.generateCodeFromRequirements(requirements, blueprint, preferences);

      expect(mockAgent.generateComponentCode).toHaveBeenCalled();
      expect(mockAgent.generateApiCode).toHaveBeenCalled();
      expect(code).toHaveProperty('frontend');
      expect(code).toHaveProperty('backend');
      expect(code).toHaveProperty('tokenUsage');
      expect(code.tokenUsage).toHaveProperty('total');
      expect(mockAgent.trackTokenUsage).toHaveBeenCalled();
    });

    test('should skip code generation when token budget exceeded', async () => {
      const requirements = 'Create a user authentication system';
      const blueprint = { frontend: 'React.js', backend: 'Node.js' };
      const preferences = { codingStyle: 'Functional', testing: 'Jest' };

      mockAgent.generateComponentCode = jest.fn().mockResolvedValue('export const Auth = () => {};');
      mockAgent.generateApiCode = jest.fn().mockResolvedValue('app.post("/auth", handler);');
      mockAgent.getTokenBudget = jest.fn().mockResolvedValue({ remaining: 500, used: 0 });
      mockAgent.checkTokenBudget = jest.fn().mockReturnValue(false);
      mockAgent.estimateCodeTokens = jest.fn().mockResolvedValue(1000);
      mockAgent.trackTokenUsage = jest.fn().mockResolvedValue(0);

      const code = await mockAgent.generateCodeFromRequirements(requirements, blueprint, preferences);

      expect(mockAgent.generateComponentCode).not.toHaveBeenCalled();
      expect(mockAgent.generateApiCode).not.toHaveBeenCalled();
      expect(code.frontend).toBe('');
      expect(code.backend).toBe('');
    });

    test('should load blueprint from planning documents', async () => {
      fs.readdir.mockResolvedValue(['technical-blueprint.md']);
      fs.readFile.mockResolvedValue(`
# Technical Blueprint
## Architecture
Frontend: React.js
Backend: Node.js/Express
Database: PostgreSQL
      `);

      const blueprint = await mockAgent.loadBlueprintFromPlanning();

      expect(blueprint).toHaveProperty('frontend', 'React.js');
      expect(blueprint).toHaveProperty('backend', 'Node.js/Express');
      expect(blueprint).toHaveProperty('database', 'PostgreSQL');
    });

    test('should load requirements from specifications', async () => {
      fs.readdir.mockResolvedValue(['product-specification.md']);
      fs.readFile.mockResolvedValue(`
# Product Specification
### Functional Requirements
- User authentication system
- Profile management
- Data validation
      `);

      const requirements = await mockAgent.loadRequirementsFromSpecs();

      expect(requirements).toContain('User authentication system');
      expect(requirements).toContain('Profile management');
    });

    test('should handle missing planning documents gracefully', async () => {
      fs.readdir.mockRejectedValue(new Error('Directory not found'));

      const blueprint = await mockAgent.loadBlueprintFromPlanning();

      expect(blueprint).toBeNull();
    });
  });

  describe('Quality gate methods', () => {
    beforeEach(async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      mockAgent = new ImplementationAgent();
      await mockAgent.initialize();
    });

    test('should run ESLint on code', async () => {
      const codeContent = 'function test() { return true; }';
      const filePath = '/mock/project/src/test.js';

      // Mock successful linting
      const lintResults = { passed: true, errors: [] };

      mockAgent.runLinter = jest.fn().mockResolvedValue(lintResults);

      const results = await mockAgent.runLinter(filePath, codeContent);

      expect(results.passed).toBe(true);
      expect(results.errors).toEqual([]);
    });

    test('should run tests and get coverage', async () => {
      const testResults = { passed: true, coverage: 90, duration: 250 };

      mockAgent.runTests = jest.fn().mockResolvedValue(testResults);

      const results = await mockAgent.runTests('/mock/project');

      expect(results.passed).toBe(true);
      expect(results.coverage).toBe(90);
      expect(results.duration).toBe(250);
    });

    test('should perform security scan', async () => {
      const securityResults = { passed: true, vulnerabilities: [], score: 95 };

      mockAgent.runSecurityScan = jest.fn().mockResolvedValue(securityResults);

      const results = await mockAgent.runSecurityScan('/mock/project');

      expect(results.passed).toBe(true);
      expect(results.vulnerabilities).toEqual([]);
      expect(results.score).toBe(95);
    });

    test('should fail quality gates when tests fail', async () => {
      mockAgent.runLinter = jest.fn().mockResolvedValue({ passed: true });
      mockAgent.runTests = jest.fn().mockResolvedValue({ passed: false, coverage: 45 });
      mockAgent.runSecurityScan = jest.fn().mockResolvedValue({ passed: true });

      const results = await mockAgent.runQualityGates('/mock/file.js', 'code content');

      expect(results.overall).toBe(false);
      expect(results.testing.passed).toBe(false);
    });
  });

  describe('implementationCommand execution', () => {
    let consoleSpy;

    beforeEach(() => {
      consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    });

    afterEach(() => {
      consoleSpy.mockRestore();
    });

    test('should show guide by default', async () => {
      const { implementationCommand } = require('../commands/implementation');

      await implementationCommand('guide', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Phase 3 Implementation Guide')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Phase 3 Objective:')
      );
    });

    test('should create code generation template', async () => {
      const { implementationCommand } = require('../commands/implementation');

      await implementationCommand('generate', { template: true });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ”§ Code Generation')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('âœ… Code generation template created')
      );
      expect(fs.writeFile).toHaveBeenCalled();
    });

    test('should run quality gates on codebase', async () => {
      const { implementationCommand } = require('../commands/implementation');

      await implementationCommand('quality', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ›¡ï¸ Quality Gates')
      );
    });

    test('should show progress tracking', async () => {
      const { implementationCommand } = require('../commands/implementation');

      await implementationCommand('progress', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ“Š Implementation Progress')
      );
    });

    test('should estimate implementation tokens', async () => {
      const { implementationCommand } = require('../commands/implementation');

      await implementationCommand('estimate', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸª™ Token Estimation')
      );
    });

    test('should list implementation documents', async () => {
      const { implementationCommand } = require('../commands/implementation');

      fs.readdir.mockResolvedValue(['code-structure.md', 'progress.md']);

      await implementationCommand('list', {});

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('ðŸ“ Existing Implementation Documents')
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Found 2 document(s)')
      );
    });

    test('should handle invalid phase', async () => {
      const { implementationCommand } = require('../commands/implementation');

      projectDetector.getProjectStatus.mockResolvedValue({
        phase: 2,
        task: 'Create technical blueprint',
        role: 'Software Architect'
      });

      await implementationCommand('generate', { template: true });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Implementation Agent is designed for Phase 3')
      );
      expect(fs.writeFile).not.toHaveBeenCalled();
    });
  });

  describe('Template content validation', () => {
    test('code generation template should have all required sections', async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      const agent = new ImplementationAgent();
      await agent.initialize();

      const template = await agent.createCodeGenerationTemplate();

      expect(template).toContain('## Architecture Overview');
      expect(template).toContain('## Code Structure');
      expect(template).toContain('## Quality Gates');
      expect(template).toContain('## Progress Tracking');
      expect(template).toContain('## Token Management');
      expect(template).toContain('## Best Practices');
    });

    test('progress template should track implementation status', async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      const agent = new ImplementationAgent();
      await agent.initialize();

      const template = await agent.createProgressTemplate();

      expect(template).toContain('# Implementation Progress');
      expect(template).toContain('## Current Status');
      expect(template).toContain('## Completed Tasks');
      expect(template).toContain('## In Progress');
      expect(template).toContain('## Next Steps');
      expect(template).toContain('## Blockers');
    });

    test('quality gates template should define standards', async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      const agent = new ImplementationAgent();
      await agent.initialize();

      const template = await agent.createQualityGatesTemplate();

      expect(template).toContain('# Quality Gates');
      expect(template).toContain('## Code Quality');
      expect(template).toContain('## Testing Standards');
      expect(template).toContain('## Security Requirements');
      expect(template).toContain('## Performance Benchmarks');
      expect(template).toContain('## Acceptance Criteria');
    });
  });

  describe('Error handling', () => {
    test('should handle initialization errors', async () => {
      config.load.mockRejectedValue(new Error('Config load failed'));

      const { ImplementationAgent } = require('../commands/implementation');
      const agent = new ImplementationAgent();

      await expect(agent.initialize()).rejects.toThrow('Config load failed');
    });

    test('should handle code generation errors', async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      const agent = new ImplementationAgent();
      agent.implementationDir = '/mock/path';

      fs.writeFile.mockRejectedValue(new Error('Write failed'));

      await expect(agent.saveGeneratedCode('test.js', 'code')).rejects.toThrow('Write failed');
    });

    test('should handle quality gate failures gracefully', async () => {
      const { ImplementationAgent } = require('../commands/implementation');
      const agent = new ImplementationAgent();
      await agent.initialize();

      agent.runLinter = jest.fn().mockRejectedValue(new Error('Linting failed'));
      agent.runTests = jest.fn().mockResolvedValue({ passed: true });
      agent.runSecurityScan = jest.fn().mockResolvedValue({ passed: true });

      const results = await agent.runQualityGates('/mock/file.js', 'code');

      expect(results.linting.passed).toBe(false);
      expect(results.linting.error).toBe('Linting failed');
      expect(results.overall).toBe(false);
    });
  });
});